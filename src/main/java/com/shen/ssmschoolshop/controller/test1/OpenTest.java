package com.shen.ssmschoolshop.controller.test1;

import com.shen.ssmschoolshop.model.Result;
import com.shen.ssmschoolshop.model.TestResult111;
import com.shen.ssmschoolshop.model.test.ComplexVO;
import com.shen.ssmschoolshop.model.test.User;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Created by Shen Peihong on 2020/7/2 23:52
 * Description:
 *
 * @since 1.0.0
 */
@RestController
@RequestMapping("/ptl1")
public class OpenTest {

    /**
     * data返回String类型给前端
     * @return
     */
    @RequestMapping("/test0.do")
    public Result test0(){
        String str = "test";
        Result result = new Result(str);
        return result;
    }

    /**
     * 返回Float类型给前端
     */
    @RequestMapping("/test1.do")
    public Result test1(){
        Float str = 1.1f;
        Result result = new Result(str);
        return result;
    }

    /**
     * 返回Double类型给前端
     * @return
     */
    @RequestMapping("/test2.do")
    public Result test2(){
        Double str = 1.1d;
        Result result = new Result(str);
        return result;
    }

    /**
     * 返回一个String[]数组给前端  返回一个数组 里面的值都是String类型的
     * @return
     */
    @RequestMapping("/test3.do")
    public Result test3(){
        String[] str = new String[]{"123","456","789"};
        Result result = new Result(str);
        return result;
    }

    /**
     * 返回一个List<String>类型给前端 效果是跟String[]数组一样的，因为List的类型 向下转型是ArrayList 底层也是数组
     * @return
     */
    @RequestMapping("/test4.do")
    public Result test4(){
        List<String> list = new ArrayList<>();
        list.add("123");
        list.add("456");
        list.add("789");
        Result result = new Result(list);
        return result;
    }

    /**
     * 返回一个List<PO>类， PO类代表里面的值都是简单类型
     * @return
     */
    @RequestMapping("/test5.do")
    public Result test5(){
        int i = 0;
        List<User> list = new ArrayList<>();
        User u1 = new User(1,"zhangsan","zhangsan");
        User u2 = new User(2,"lisi","lisi");
        User u3 = new User(3,"wangwu","wangwu");
        list.add(u1);
        list.add(u2);
        list.add(u3);
        //data所对应的值就是list类型
        return new Result(list);
    }

    /**
     * 返回Set类型的值 返回的是无序的值 Set也即是插入的时候是无序的
     * @return
     */
    @RequestMapping("/test6.do")
    public Result test6(){
        Set<User> list = new HashSet<>();
        User u1 = new User(1,"zhangsan","zhangsan");
        User u2 = new User(2,"lisi","lisi");
        User u3 = new User(3,"wangwu","wangwu");
        list.add(u1);
        list.add(u2);
        list.add(u3);
        //data所对应的值就是list类型
        return new Result(list);
    }

    /**
     * 来个复杂一点的VO，什么类型都有的那种
     * @return
     */
    @RequestMapping("/test7.do")
    public Result test7(){
        ComplexVO complexVO = new ComplexVO();
        String username = "username";
        complexVO.setId(username);
        Map<String,Object> map = new HashMap<>();
        map.put("one","one");
        map.put("two","two");
        complexVO.setMap(map);
        String[] array = new String[]{"array1","array2"};
        complexVO.setArray(array);
        List<String> list = new ArrayList<>();
        list.add("stringlist1");
        list.add("stringlist2");
        complexVO.setList(list);
        List<User> userList = new ArrayList<>();
        User user = new User(1,"213123","45454",-1);
        userList.add(user);
        complexVO.setUserList(userList);
        Result result = new Result(complexVO);
        return result;
    }

    /**
     * 返回HashMap类型的值
     * @return
     */
    @RequestMapping("/testTemp.do")
    public Map<String,Object> testTemp(){
        Map<String, Object> map = new HashMap<String, Object>() {{
            put("username","123");
            put("password","456");
        }};
        return map;
    }

    /**
     * 测试一些lambda表达式 groupingBy  一些归类日期数据可以用上
     * @return
     */
    @RequestMapping("/test8.do")
    public Result test8(){
        //List<VO类> 对某个元素进行分组，返回是一个Map类型，左边是分组类型，右边是分组后的值，类型是List<原来的VO类型>   一个参数的话默认就是右边是List类型的
        List<User> list = new ArrayList<>();
        User u1 = new User(1,"zhangsan","zhangsan",-1);
        User u2 = new User(2,"zz","zz",1);
        User u3 = new User(3,"ww","ww",1);
        User u4 = new User(4,"dd","dd",-1);
        User u5 = new User(5,"cc","cc",-1);
        list.add(u1);
        list.add(u2);
        list.add(u3);
        list.add(u4);
        list.add(u5);
        Map<Integer, List<User>> collect = list.stream().collect(Collectors.groupingBy(User::getParentId)); //一个参数的时候，默认就是value是List<>类型
        Result result = new Result(collect);
        return result;
    }

    /**
     * groupingBy 两个参数，去指定value返回的类型
     * @return
     */
    @RequestMapping("/test9.do")
    public Result test9(){
        List<User> list = new ArrayList<>();
        User u1 = new User(1,"zhangsan","zhangsan",-1);
        User u2 = new User(2,"zz","zz",1);
        User u3 = new User(3,"ww","ww",1);
        User u4 = new User(4,"dd","dd",-1);
        User u5 = new User(5,"cc","cc",-1);
        list.add(u1);
        list.add(u2);
        list.add(u3);
        list.add(u4);
        list.add(u5);
        Map<Integer, Set<User>> collect = list.stream().collect(Collectors.groupingBy(User::getParentId,Collectors.toSet())); //一个参数的时候，默认就是value是List<>类型
        //这个一般前端不要求顺序的话，就可以使用这个，要是有顺序要求的话，那还是要使用List
        Result result = new Result(collect);
        return result;
    }

    /**
     * groupingBy 三个参数，既指定value返回的类型 也指定了外层Map的类型
     * @return
     */
    @RequestMapping("/test10.do")
    public Result test10(){
        List<User> list = new ArrayList<>();
        User u1 = new User(1,"zhangsan","zhangsan",-1);
        User u2 = new User(2,"zz","zz",1);
        User u3 = new User(3,"ww","ww",1);
        User u4 = new User(4,"dd","dd",-1);
        User u5 = new User(5,"cc","cc",-1);
        list.add(u1);
        list.add(u2);
        list.add(u3);
        list.add(u4);
        list.add(u5);
        Map<Integer, Set<User>> collect = list.stream().collect(Collectors.groupingBy(User::getParentId,LinkedHashMap::new,Collectors.toSet())); //一个参数的时候，默认就是value是List<>类型
        //这个一般前端不要求顺序的话，就可以使用这个，要是有顺序要求的话，那还是要使用List
        Result result = new Result(collect);
        return result;
    }

    /**
     * 试试partitioningBy() 按照条件表达式去及逆行分组
     * @return
     */
    @RequestMapping("/test11.do")
    public Result test11(){
        List<User> list = new ArrayList<>();
        User u1 = new User(1,"zhangsan","zhangsan",-1);
        User u2 = new User(2,"zz","zz",1);
        User u3 = new User(3,"ww","ww",1);
        User u4 = new User(4,"dd","dd",-1);
        User u5 = new User(5,"cc","cc",-1);
        list.add(u1);
        list.add(u2);
        list.add(u3);
        list.add(u4);
        list.add(u5);
        //需求是返回及格和不及格的人的list
        //及格是true
        long l = System.currentTimeMillis();
        Map<Boolean, List<User>> collect = list.stream().collect(Collectors.partitioningBy(e -> e.getId() < 3));//ID小于3的人为true ，大于等于3的就为false
        Result result = new Result(collect);
        return result;
    }
}
